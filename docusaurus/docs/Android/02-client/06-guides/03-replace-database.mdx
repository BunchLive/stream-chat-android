import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Replace Database

The offline support module uses Room as the ORM to handle persistence in the Stream Chat SDK, but it is possible to use a custom 
persistence library by injecting custom Repositories in the SDK. 

To show how to substitute Room to another ORM we elaborated a tutorial showing how to use Realm with Stream's SDK. With some modifications
in the code of this tutorial, you will able to use any other database.

## Using a custom RepositoryFactoryProvider

`ChatClient.Builder` allows the user to substitute the Repositories classes in the SDK. These classes are used by the entire 
SDK to access data from the database, so by changing then you will be able to use the database of your preference. You can call a 
`withRepositoryFactoryProvider`  with a custom implementation of `RepositoryFactory.Provider`. This is a functional interface that only provides 
[RepositoryFactory](https://github.com/GetStream/stream-chat-android/blob/main/stream-chat-android-client/src/main/java/io/getstream/chat/android/client/persistance/repository/factory/RepositoryFactory.kt):

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```
val client = ChatClient.Builder(apiKey, context)
    .withRepositoryFactoryProvider { RealmRepositoryFactory(provideRealm()) }
    .build()
    
public fun configureRealm(): Realm =
    RealmConfiguration.Builder(schema = realmSchema())
        .schemaVersion(SCHEMA_VERSION)
        .deleteRealmIfMigrationNeeded()
        .build()
        .let(Realm::open)    
```

</TabItem>

<TabItem value="java" label="Java">

```
// Todo!
```

</TabItem>
</Tabs>

:::note
We will cover realmSchema() later in this documentation.
::: 

`RepositoryFactory` in the access point for all the `Repositories` of the SDK, so they must be provided by this interface:

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
public class RealmRepositoryFactory(private val realm: Realm) : RepositoryFactory {
    override fun createUserRepository(): UserRepository = RealmUserRepository(realm)

    override fun createChannelConfigRepository(): ChannelConfigRepository = RealmChannelConfigRepository(realm)

    override fun createQueryChannelsRepository(): QueryChannelsRepository = RealmQueryChannelsRepository(realm)

    override fun createSyncStateRepository(): SyncStateRepository = RealmSyncStateRepository(realm)

    override fun createAttachmentRepository(): AttachmentRepository = RealmAttachmentRepository(realm)

    override fun createReactionRepository(
        getUser: suspend (userId: String) -> User,
    ): ReactionRepository = RealmReactionRepository(realm)

    override fun createMessageRepository(
        getUser: suspend (userId: String) -> User,
    ): MessageRepository = RealmMessageRepository(realm)

    override fun createChannelRepository(
        getUser: suspend (userId: String) -> User,
        getMessage: suspend (messageId: String) -> Message?,
    ): ChannelRepository = RealmChannelRepository(realm)
}
```

</TabItem>

<TabItem value="java" label="Java">

```
// Todo!
```

</TabItem>
</Tabs>

:::caution 
All the Repositories should be provided with real implementations. Using a `Repository` that doesn't provide real data may create unpredicted states because all the repositories are connected to SDK and are essencial to it. Mocking one or more repositories may prevent the SDK to work correctly.
:::

## Implementing ChannelRepository

To save to and fetch channels from Realm, it is necessary to implement a version of ChannelRepository interface that handles Realm. You can find the following implementation with some of the methods: 

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin
public class RealmChannelRepository(private val realm: Realm) : ChannelRepository {
	override suspend fun clear() {
        realm.writeBlocking {
            query<ChannelEntityRealm>().find().let(this::delete)
        }
    }
    
    override suspend fun deleteChannel(cid: String) {
        val channel = realm.query<ChannelEntityRealm>("cid == '$cid'")
            .first()
            .find()

        realm.writeBlocking {
            channel?.let(::findLatest)?.let(::delete)
        }
    }
    
    override suspend fun insertChannel(channel: Channel) {
        realm.writeBlocking {
            this.copyToRealm(channel.toRealm(), updatePolicy = UpdatePolicy.ALL)
        }
    }
    
    override suspend fun selectChannelByCid(cid: String): Channel? =
        selectChannelByCidRealm(cid)?.toDomain()
    
    private fun selectChannelByCidRealm(cid: String): ChannelEntityRealm? =
        realm.query<ChannelEntityRealm>("cid == '$cid'")
            .first()
            .find()
            
    // All the other methods must be implemented, following this same approach.
}
```

</TabItem>

<TabItem value="java" label="Java">

```
// Todo!
```

</TabItem>

</Tabs>

This is the key of changing the database in the Stream Android SDK. All you need to do is implement the `Repository` interfaces handling the database of choice.

As you can, see in order to Realm understand how to save your data, you must create a scheme. So the model classes you the SDK logic must be represented as `Entity` classes. Those are: 

- AttachmentEntity
- ChannelEntity
- ChannelUserReadEntity
- ConfigEntity
- CommandEntity
- MemberEntity
- MessageEntity
- QueryChannelsEntity
- QuerySorterInfoEntity
- SortSpecificationEntity
- ReactionCountEntity
- ReactionEntity
- ReactionScoreEntity
- SyncStateEntity
- UploadStateEntity
- UserEntity


Most of the entities creation is trivial and based in the model class. All is needed is to create the class and functions to convert Entity to Model and Model to Entity. Like the following example: 

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```
internal class ChannelEntityRealm : RealmObject {
    @PrimaryKey
    var cid: String = ""
    var channel_id: String = ""
    var type: String = ""
    var name: String = ""
    var image: String = ""
    var cooldown: Int = 0
    var created_by: UserEntityRealm? = null
    var frozen: Boolean = false
    var hidden: Boolean? = null
    var hide_messages_before: RealmInstant? = null
    var member_count: Int = 0
    var messages: RealmList<MessageEntityRealm> = realmListOf()
    var members: RealmList<MemberEntityRealm> = realmListOf()
    var watchers: RealmList<UserEntityRealm> = realmListOf()
    var watcher_count: Int = 0
    var last_message_at: RealmInstant? = null
    var last_message_id: String = ""
    var reads: RealmList<ChannelUserReadEntityRealm> = realmListOf()
    var created_at: RealmInstant? = null
    var updated_at: RealmInstant? = null
    var deleted_at: RealmInstant? = null
    var extra_data: MutableMap<String, Any> = mutableMapOf()
    var sync_status: Int = SyncStatus.COMPLETED.status
    var team: String = ""
    var own_capabilities: Set<String> = emptySet()
    var membership: MemberEntityRealm? = null
}

internal fun Channel.toRealm(): ChannelEntityRealm {
    val thisChannel = this
    return ChannelEntityRealm().apply {
        cid = thisChannel.cid
        type = thisChannel.type
        channel_id = thisChannel.id
        name = thisChannel.name
        image = thisChannel.image
        cooldown = thisChannel.cooldown
        created_by = thisChannel.createdBy.toRealm()
        frozen = thisChannel.frozen
        hidden = thisChannel.hidden
        hide_messages_before = thisChannel.hiddenMessagesBefore?.toRealmInstant()
        messages = thisChannel.messages.map { message -> message.toRealm() }.toRealmList()
        member_count = thisChannel.memberCount
        members = thisChannel.members.map { member -> member.toRealm() }.toRealmList()
        watchers = thisChannel.watchers.map { it.toRealm() }.toRealmList()
        watcher_count = thisChannel.watcherCount
        last_message_at = thisChannel.lastMessageAt?.toRealmInstant()
        last_message_id = thisChannel.lastMessage()?.id ?: ""
        created_at = thisChannel.createdAt?.toRealmInstant()
        updated_at = thisChannel.updatedAt?.toRealmInstant()
        deleted_at = thisChannel.deletedAt?.toRealmInstant()
        extra_data = thisChannel.extraData
        sync_status = thisChannel.syncStatus.toRealm()
        team = thisChannel.team
        own_capabilities = thisChannel.ownCapabilities
    }
}

internal fun ChannelEntityRealm.toDomain(): Channel =
    Channel(
        id = this.channel_id,
        type = this.type,
        name = this.name,
        image = this.image,
        watcherCount = this.watcher_count,
        frozen = this.frozen,
        lastMessageAt = this.last_message_at?.toDate(),
        createdAt = this.created_at?.toDate(),
        deletedAt = this.deleted_at?.toDate(),
        updatedAt = this.updated_at?.toDate(),
        syncStatus = this.sync_status.toDomain(),
        members = members.map { it.toDomain() },
        memberCount = this.member_count,
        messages = messages.map { messageEntityRealm -> messageEntityRealm.toDomain() },
        createdBy = this.created_by?.toDomain() ?: User(),
        watchers = watchers.map { watcher -> watcher.toDomain() },
        team = this.team,
        read = reads.map { readEntity -> readEntity.toDomain() },
        hidden = this.hidden,
        hiddenMessagesBefore = this.hide_messages_before?.toDate(),
        cooldown = this.cooldown,
        ownCapabilities = this.own_capabilities,
        membership = this.membership?.toDomain(),
        extraData = this.extra_data
    )

internal fun Channel.lastMessage(): Message? = messages.lastOrNull()

```

</TabItem>

<TabItem value="java" label="Java">

```
// Todo!
```

</TabItem>

</Tabs>

The exceptions to the Entity classes is `QueryChannelsEntityRealm` and `QuerySorterInfoEntityRealm`. 

`QueryChannelsEntityRealm` has the information about the filters used in the queries. The filters are can stored as graph where each node represents a filter that may or may not be composed by one or more filters. Example: The `And` filter is composed by many other filters and the `Equals` filter is composed by two values and an operation. We discuss in detail how to store this data in the next section. 

`QuerySorterInfoEntityRealm` [Write this section later.]

## Storing QueryChannelsEntityRealm

To define the `QueryChannelsEntityRealm`, we define the filters as a string that will be parsed using moshi. Filters of search should not be a very complex graph will hundreds of node, so keeping the filter as string should not be a problem for most cases. It is advisable to review the filter logic, if the the filter become very big. `QueryChannelsEntityRealm` can be defined in the following way:

<Tabs>
<TabItem value="kotlin" label="Kotlin">


```kotlin
internal class QueryChannelsEntityRealm : RealmObject {
    @PrimaryKey
    var id: String = ""
    var filter_as_string: String? = null
    var query_sort: QuerySorterInfoEntityRealm? = null
    var cids: RealmList<String> = realmListOf()
}
```

</TabItem>

<TabItem value="java" label="Java">

```
// Todo!
```

</TabItem>

</Tabs>

The conversion of `QueryChannelsEntityRealm` can be done by converting the Filter in and out to String using an adapter of Moshi:


<Tabs>
<TabItem value="kotlin" label="Kotlin">

```
internal fun QueryChannelsSpec.toRealm(): QueryChannelsEntityRealm {
    val thisQuery = this
    val adapter = filterNodeAdapter()

    return QueryChannelsEntityRealm().apply {
        id = generateQuerySpecId(thisQuery.filter, thisQuery.querySort)
        filter_as_string = adapter.toJson(thisQuery.filter.toFilterNode())
        query_sort = thisQuery.querySort.toRealm()
        cids = thisQuery.cids.toRealmList()
    }
}

@OptIn(ExperimentalStdlibApi::class)
private fun filterNodeAdapter() =
    Moshi.Builder()
        .addAdapter(FilterNodeAdapter())
        .build()
        .adapter(FilterNode::class.java)

internal fun generateQuerySpecId(filter: FilterObject, querySort: QuerySorter<out Channel>): String {
    return "${filter.hashCode()}-${querySort.toDto().hashCode()}"
}
```

</TabItem>

<TabItem value="java" label="Java">

```
// Todo!
```

</TabItem>

</Tabs>

We need to define the adapter for the serialization and deserialization. So let's start defining the structure of our `Filters`. 

The Filters are represented as a graph. Let's represent the graph as `Nodes` and  `Edges`



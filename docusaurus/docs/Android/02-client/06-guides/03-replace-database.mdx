import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Replace Database

The offline support module uses Room as the ORM to handle persistence in the Stream Chat SDK, but it is possible to use a custom 
persistence library by injecting custom Repositories in the SDK. 

To show how to substitute Room to another ORM we elaborated a tutorial showing how to use Realm with Stream's SDK. With some modifications
in the code of this tutorial, you will able to use any other database.

## Using a custom RepositoryFactoryProvider

`ChatClient.Builder` allows the user to substitute the Repositories classes in the SDK. These classes are used by the entire 
SDK to access data from the database, so by changing then you will be able to use the database of your preference. You can call a 
`withRepositoryFactoryProvider`  with a custom implementation of `RepositoryFactory.Provider`. This is a functional interface that only provides 
[RepositoryFactory](https://github.com/GetStream/stream-chat-android/blob/main/stream-chat-android-client/src/main/java/io/getstream/chat/android/client/persistance/repository/factory/RepositoryFactory.kt):

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```
val client = ChatClient.Builder(apiKey, context)
    .withRepositoryFactoryProvider { RealmRepositoryFactory(provideRealm()) }
    .build()
    
public fun configureRealm(): Realm =
    RealmConfiguration.Builder(schema = realmSchema())
        .schemaVersion(SCHEMA_VERSION)
        .deleteRealmIfMigrationNeeded()
        .build()
        .let(Realm::open)    
```

</TabItem>

<TabItem value="java" label="Java">

```
// Todo!
```

</TabItem>
</Tabs>

:::note
We will cover realmSchema() later in this documentation.
::: 

`RepositoryFactory` in the access point for all the `Repositories` of the SDK, so they must be provided by this interface:

<Tabs>
<TabItem value="kotlin" label="Kotlin">

```kotlin 
public class RealmRepositoryFactory(private val realm: Realm) : RepositoryFactory {
    override fun createUserRepository(): UserRepository = RealmUserRepository(realm)

    override fun createChannelConfigRepository(): ChannelConfigRepository = RealmChannelConfigRepository(realm)

    override fun createQueryChannelsRepository(): QueryChannelsRepository = RealmQueryChannelsRepository(realm)

    override fun createSyncStateRepository(): SyncStateRepository = RealmSyncStateRepository(realm)

    override fun createAttachmentRepository(): AttachmentRepository = RealmAttachmentRepository(realm)

    override fun createReactionRepository(
        getUser: suspend (userId: String) -> User,
    ): ReactionRepository = RealmReactionRepository(realm)

    override fun createMessageRepository(
        getUser: suspend (userId: String) -> User,
    ): MessageRepository = RealmMessageRepository(realm)

    override fun createChannelRepository(
        getUser: suspend (userId: String) -> User,
        getMessage: suspend (messageId: String) -> Message?,
    ): ChannelRepository = RealmChannelRepository(realm)
}
```

</TabItem>

<TabItem value="java" label="Java">

```
// Todo!
```

</TabItem>
</Tabs>

:::caution 
All the Repositories should be provided with real implementations. Using a `Repository` that doesn't provide real data may create unpredicted states because all the repositories are connected to SDK and are essencial to it. Mocking one or more repositories may prevent the SDK to work correctly.
:::

## Implementing ChannelRepository

To save to and fetch channels from Realm, it is necessary to implement a version of ChannelRepository interface that handles Realm. You can find the following implementation with some of the methods: 

```
public class RealmChannelRepository(private val realm: Realm) : ChannelRepository {
	override suspend fun clear() {
        realm.writeBlocking {
            query<ChannelEntityRealm>().find().let(this::delete)
        }
    }
    
    override suspend fun deleteChannel(cid: String) {
        val channel = realm.query<ChannelEntityRealm>("cid == '$cid'")
            .first()
            .find()

        realm.writeBlocking {
            channel?.let(::findLatest)?.let(::delete)
        }
    }
    
    override suspend fun insertChannel(channel: Channel) {
        realm.writeBlocking {
            this.copyToRealm(channel.toRealm(), updatePolicy = UpdatePolicy.ALL)
        }
    }
    
    override suspend fun selectChannelByCid(cid: String): Channel? =
        selectChannelByCidRealm(cid)?.toDomain()
    
    private fun selectChannelByCidRealm(cid: String): ChannelEntityRealm? =
        realm.query<ChannelEntityRealm>("cid == '$cid'")
            .first()
            .find()
            
    // All the other methods must be implemented, following this same approach.
}
```

This is the key of changing the database in the Stream Android SDK. All you need to do is implement the `Repository` interfaces handling the database of choice.

As you can, see in order to Realm understand how to save your data, you must create a scheme. So the model classes you the SDK logic must be represented as `Entity` classes. Those are: 

todo: Remove Realm from all entities
- AttachmentEntityRealm
- ChannelEntityRealm
- ChannelUserReadEntityRealm
- ConfigEntityRealm
- CommandEntityRealm
- MemberEntityRealm
- MessageEntityRealm
- QueryChannelsEntityRealm
- QuerySorterInfoEntityRealm
- SortSpecificationEntityRealm
- ReactionCountEntityRealm
- ReactionEntityRealm
- ReactionScoreEntityRealm
- SyncStateEntityRealm
- UploadStateEntityRealm
- UserEntityRealm


